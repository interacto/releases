import type { Flushable } from "./Flushable";
import type { EventType } from "../../api/fsm/EventType";
import type { FSM } from "../../api/fsm/FSM";
import type { OutputState } from "../../api/fsm/OutputState";
import type { Interaction } from "../../api/interaction/Interaction";
import type { InteractionData } from "../../api/interaction/InteractionData";
import type { VisitorInteraction } from "../../api/interaction/VisitorInteraction";
import type { Logger } from "../../api/logging/Logger";
interface CancellablePromise extends Promise<void> {
    cancel: () => void;
}
export type InteractionDataImplType<T> = T extends InteractionBase<any, infer DImpl, any> ? DImpl : never;
export declare abstract class InteractionBase<D extends InteractionData, DImpl extends D & Flushable, F extends FSM> implements Interaction<D> {
    protected readonly _registeredNodes: Set<unknown>;
    protected readonly _dynamicRegisteredNodes: Set<unknown>;
    protected readonly _fsm: F;
    protected readonly _name: string;
    protected _log: boolean;
    protected readonly mutationObservers: Array<MutationObserver>;
    protected readonly _data: DImpl;
    protected readonly logger: Logger;
    private mouseHandler?;
    private touchHandler?;
    private keyHandler?;
    private uiHandler?;
    private actionHandler?;
    private readonly disposable;
    private stopImmediatePropag;
    private preventDef;
    protected activated: boolean;
    protected throttleTimeout: number;
    protected currentThrottling: CancellablePromise | undefined;
    protected latestThrottledEvent: Event | undefined;
    protected constructor(fsm: F, data: DImpl, logger: Logger, name: string);
    reinitData(): void;
    get data(): D;
    get name(): string;
    setThrottleTimeout(timeout: number): void;
    private createThrottleTimeout;
    private checkThrottlingEvent;
    protected updateEventsRegistered(newState: OutputState, oldState: OutputState): void;
    protected getCurrentAcceptedEvents(state: OutputState): ReadonlyArray<EventType>;
    private callBackMutationObserver;
    protected getEventTypesOf(state: OutputState): ReadonlySet<EventType>;
    registerToNodes(widgets: ReadonlyArray<unknown>): void;
    protected unregisterFromNodes(widgets: ReadonlyArray<unknown>): void;
    onNodeUnregistered(node: unknown): void;
    onNewNodeRegistered(node: unknown): void;
    registerToNodeChildren(elementToObserve: Node): void;
    protected registerEventToNode(eventType: EventType, node: unknown): void;
    protected unregisterEventToNode(eventType: EventType, node: unknown): void;
    protected registerActionHandlerClick(node: EventTarget): void;
    protected unregisterActionHandlerClick(node: EventTarget): void;
    protected registerActionHandlerInput(node: EventTarget): void;
    protected unregisterActionHandlerInput(node: EventTarget): void;
    protected getActionHandler(): EventListener;
    protected getMouseHandler(): EventListener;
    protected getTouchHandler(): EventListener;
    protected getKeyHandler(): EventListener;
    protected getUIHandler(): EventListener;
    isRunning(): boolean;
    fullReinit(): void;
    set stopImmediatePropagation(stop: boolean);
    get stopImmediatePropagation(): boolean;
    set preventDefault(prevent: boolean);
    get preventDefault(): boolean;
    processEvent(event: Event): void;
    private directEventProcess;
    log(log: boolean): void;
    isActivated(): boolean;
    setActivated(activated: boolean): void;
    get fsm(): F;
    reinit(): void;
    uninstall(): void;
    acceptVisitor(visitor: VisitorInteraction): void;
    get registeredNodes(): ReadonlySet<unknown>;
    get dynamicRegisteredNodes(): ReadonlySet<unknown>;
}
export {};
